---
id: L-108
date: 2024.02.15
category: DEV
title: 'Building a Real-Time WebSocket Dashboard'
readTime: 8 MIN
preview: 'Implementing a live monitoring dashboard with WebSockets, React, and D3.js for visualizing streaming sensor data.'
tags:
  - websocket
  - react
  - real-time
---
# Building a Real-Time WebSocket Dashboard

## The Problem

Most dashboards poll APIs at fixed intervals. For our IoT sensor network, we needed **sub-second latency** — polling wasn't going to cut it.

## Architecture

```
┌─────────┐    WebSocket    ┌──────────┐    React State    ┌───────────┐
│ Sensors │ ──────────────> │  Server  │ ────────────────> │ Dashboard │
└─────────┘                 └──────────┘                   └───────────┘
```

## Implementation

The key was using a custom `useWebSocket` hook:

```typescript
const useWebSocket = (url: string) => {
  const [data, setData] = useState<SensorData[]>([]);
  const wsRef = useRef<WebSocket | null>(null);

  useEffect(() => {
    wsRef.current = new WebSocket(url);
    wsRef.current.onmessage = (event) => {
      const parsed = JSON.parse(event.data);
      setData(prev => [...prev.slice(-100), parsed]);
    };
    return () => wsRef.current?.close();
  }, [url]);

  return data;
};
```

## Performance Considerations

- **Ring buffer pattern**: Keep only the last 100 data points in state
- **requestAnimationFrame**: Batch DOM updates for D3 charts
- **Web Workers**: Offload heavy data transformations

> The real bottleneck wasn't the WebSocket — it was React re-renders. Memoization was critical.

## Results

Final dashboard handles **500 messages/second** with smooth 60fps animations on a mid-range laptop.
