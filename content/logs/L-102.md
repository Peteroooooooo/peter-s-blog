---
id: L-102
date: 2023.10.05
category: DEV
title: 'Optimizing React Renders with useMemo Deep Dive'
readTime: 7 MIN
preview: 'When useMemo actually helps, when it hurts, and the mental model for making the right call every time.'
tags:
  - react
  - performance
  - tutorial
---
# Optimizing React Renders with useMemo Deep Dive

## The Common Mistake

```tsx
// ❌ WRONG: useMemo for simple values
const name = useMemo(() => user.firstName + ' ' + user.lastName, [user]);

// ✅ RIGHT: just compute it
const name = user.firstName + ' ' + user.lastName;
```

`useMemo` has overhead: it stores the previous value, compares dependencies, and manages memory. For simple computations, this overhead **exceeds the cost of just re-computing**.

## When useMemo Actually Helps

1. **Expensive computations** (>1ms)
2. **Referential equality** for child component props
3. **Derived state** from large datasets

```tsx
// ✅ GOOD: expensive filter + sort
const filteredItems = useMemo(() => {
  return items
    .filter(item => item.category === selectedCategory)
    .sort((a, b) => b.score - a.score);
}, [items, selectedCategory]);
```

## The Mental Model

Ask yourself two questions:
1. **Is this computation expensive?** If < 1ms, skip useMemo.
2. **Is referential equality important?** If the result is passed to a `React.memo` child or used in another hook's dependency array, use useMemo.

> Profile first, memoize second. Premature memoization is premature optimization.
